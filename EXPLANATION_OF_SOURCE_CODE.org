When the application starts in app/Main.hs it reads the jbeam file that I intend to process like this:

#+begin_src haskell
  contents <- BL.readFile filename
#+end_src

BL is the module alias for Data.ByteString.Lazy. A Lazy ByteString is a string type which is specially good to use to when working with file data. For more information regarding string types in Haskell please see https://hasufell.github.io/posts/2024-05-07-ultimate-string-guide.html
I can see that the result of the read operation is bound to the name contents.

** Parsing

After reading the contents of the file I intend to process I proceed to give contents to parseNodes which creates a tree of "Nodes".
#+begin_src haskell
      let nodes = parseNodes (BL.toStrict contents)
#+end_src

Note that the concept of a "Node" here is different from "node" in jbeam, when I mention JBeam nodes in this document I will explicitly call them JBeam nodes or call them Vertices.
In this document when I refer to nodes I mean a datatype I which I have created to represent arrays, objects and scalar inside a JBeam structure.

The Node type is defined as such:

#+begin_src haskell
  type Object = Vector Node

  type ObjectKey = (Node, Node)

  type Array = Vector Node

  data Node
    = Array Array
    | Object Object
    | ObjectKey ObjectKey
    | String Text
    | Number Scientific
    | Bool Bool
    | SinglelineComment Text
    | MultilineComment Text
    | Null
    deriving (Show, Eq)
#+end_src

type declares a type synomom for a already existing type while data declares a new type.
So a Node can be:
- a Array and contain a vector of Nodes
- a Object and contain a vector of Nodes
- a ObjectKey and contain a 2-element tuple (also called a pair) where the the first element is the key and the second is the value
- a String which contains a Text
- a Number which contains a Scientific, a numeric data type which I really like to due to it unlike most other types in many programming languages can express any arbitrary-precision decimal number without rounding errors or losing precision.
- a Bool which contains either True or False
- a MultilineComment or SinglelineComment which contains a Text
- a Null meaning that the node is empty

So in fact Node is a recursive data structure, a type which references itself.

Text is yet a another string type in Haskell which is good fit when doing appends or comparisons which I tend to do quite a lot in this codebase.

I comptemplated using something like OMap (https://hackage.haskell.org/package/ordered-containers-0.2.4/docs/Data-Map-Ordered.html) for the Object but then I realized that I do not only need support pairs of keys and values for the Object case, I also need to support the Object having Comments as direct children.
The parser is currently written using attoaparsec but I are considering to migrate to Megaparsec since Megaparsec has better support implementing error messages which can be given to the end user.

For full access to the parsing code, check the file src/Parsing.hs.

* Transforming the JBeam structure

When I talk about points in a JBeam structure, I express theese as a list of NodeSelectors. For example AnyKey would be the first key/value pair in a Object regardless of it key and ObjectKey would be the value of that key/value pair which has "nodes" as its key. So [AnyKey, ObjectKey "nodes"] would point to the Vertices ie the JBeam nodes.

A VerticeGroup is a collection of Vertices from [AnyKey, Key "nodes"] list.
To take a vector of Nodes and produce a list of VerticeGroups I need the Nodes representing the Vertices to not be interrupted by non-Vertice Nodes.

For example this is valid:

#+begin_src javascript
  ["bfl0",0.959,-1.762,0.576],
  ["bfl1",0.855,-1.788,0.707],
  ["bfl2",0.739,-1.845,0.716],
  {"group" : "nice_group"},
  ["bfr0",0.739,-1.845,0.716],
#+end_src

However this is not valid:
#+begin_src javascript
  ["bfl0",0.959,-1.762,0.576],
  ["bfl1",0.855,-1.788,0.707],
  ["bfl2",0.739,-1.845,0.716],
  {"group" : "nice_group"},
  ["bfl3",0.739,-1.845,0.716],
#+end_src

Here are the goals of this project:
- in case the JBeam structure follows the above structure:
  1. to sort the vertices inside each VerticeGroup
  2. to move incorrectly placed Vertices to their correct group
  3. to give the vertices new names based on their Z and Y values
- in case the JBeam structure does not follow the mentioned structure:
  1. find all the Vertices and create VerticeGroups for them, replacing the content at [AnyKey, ObjectKey "nodes"]
  2. make sure theese VerticeGroups follow the points for the case where
- pretty print the Node tree and save it to a file

After sucessfully parsing the node structure I can hand the Node tree to the transform function which performs sorting of the Vertices and moves Vertices betIen their groups.
The transform function only performs changes inside the path [AnyKey, ObjectKey "nodes"], it does not touch for example [AnyKey, ObjectKey "beams"] or [AnyKey, ObjectKey "triangles"].
The result of the transform operation is then handed to the formatNode function which will do the formatting but we will discuss that later, first I will explain how the tranformation works.

#+begin_src haskell
  case nodes of
  Right nodes' ->
    BL.writeFile "hewwu.jbeam"
      . encodeUtf8
      . TL.fromStrict
      . formatNode
      . transform
      $ nodes'
  Left err -> putStrLn err
#+end_src
